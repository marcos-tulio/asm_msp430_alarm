;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Descrição:
;       Este código é responsável pelo controle de um sistema básico de segurança. O
;sistema conta com um sensor de presença, buzzer, teclado 4x4 e display 16x2.
;       O sistema conta com uma senha de 8 digitos para sua validação. Esta senha pode
;ser alterada no próprio sistema e será salva na FLASH do MCU (Endereço definido no código).
;       Ao resetar o sistema com a tecla # pressionada, a senha default (00000000) é 
;definida.
;       Quando o usuário digitar a senha incorretamente por 5 vezes, o sistema será 
;travado e só será liberado após o reset.
;       Ao digitar o oitavo digito o sistema irá validar qualquer senha digitada, porém
;quando estiver digitando, o usuário poderá pressionar o "#" para limpar o display e começar
;novamente. 
;       É possível ativar ou desativar o monitoramento do sensor; ao desativar, o sistema
;entrará em standby, desativando o display e o MCU; ao ativar, o sistema contará 30 segundos
;para a ativação e após o tempo entrará em modo de standby, porém será despertado com a ativação
;do sensor.
;       Quando o sensor for ativado e o monitoramento estiver ligado o buzzer será acionado;
;Ao validar a senha o buzzer será desativado e o monitoramento idem. 
;       Quando o sistema entrar em standby o pressionamento de qualquer tecla o despertará e
;só voltará a entrar nesse modo quando o usuário ativar ou desativar o monitoramento.
;
;Detalhes das conexões:                                                              
;                                                                                                                                    
;                     _________________                            
;     Teclado (L1) --|P1.0         P2.0|-- (Display) D4                   
;     Teclado (L2) --|P1.1         P2.1|-- (Display) D5                     
;     Teclado (L3) --|P1.2         P2.2|-- (Display) D6                    
;     Teclado (L4) --|P1.3   MSP   P2.3|-- (Display) D7
;     Teclado (C1) --|P1.4  G2553  P2.4|-- (Display) RS         
;     Teclado (C2) --|P1.5         P2.5|-- (Display) E
;     Teclado (C3) --|P1.6         P2.6|-- (Display) ON/OFF
;           Buzzer --|P1.7         P2.7|-- Sensor
;                     ------------------
;
;Desenvolvido por: 
;  - Marcos Santos
;
;Desenvolvido com:
;  - IAR Embedded Workbench 5.60.2
;
;                              Desenvolvido em Maio de 2018       
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label
        
        ORG     0FFE4h                  ; Endereço da interrupção da porta 1
        DC16    P1_ISR
        
        ORG     0xFFE6                  ; Endereço da interrupção da porta 2
        DC16    P2_ISR
        
;-------------- Variáveis -------------;
TR_MENU EQU     0x200                   ; Flag para trocar de menu
CON_SEN EQU     0x202                   ; Flag para alternar entre confirmar e nova senha
FALSE   EQU     0x00    
TRUE    EQU     0x01

QTD_DIG EQU     0x204                   ; Contador de digitos já digitados
QTD_ERR EQU     0x206                   ; Contador para senhas incorretas

STATUS  EQU     0x208                   ; Endereço para armazenar o estado do sistema
INICIO  EQU     0x00                    ; Sistema em modo inicial    
DIGITAN EQU     0x01                    ; Usuário digitando a senha
TRAVADO EQU     0x02                    ; Sistema travado
VALIDAR EQU     0x03                    ; Validar senha
MENU    EQU     0x04                    ; Exibir menu 1
MENU_2  EQU     0x05                    ; Exibir menu 2
ALT_SEN EQU     0x06                    ; Alterar senha
ALT_SAV EQU     0x07                    ; Modo se salvar senha alterada
ALM_ON  EQU     0x08                    ; Alarme ativado
ALM_OFF EQU     0x09                    ; Alarme desativado
ALM_DIS EQU     0x0A                    ; Alarme disparado

SEN_DEF EQU     0x210                   ; End. da senha definida para o sistema
SEN_DIG EQU     0x220                   ; Ponteiro para armazenar a senha digitada
;SEN_SAV EQU     0xD000                  ; End. da senha salva na FLASH 
SEN_SAV EQU     0xF000                  ; End. da senha salva na FLASH (MSP430G2452)

;--------------- Strings ---------------;
        RSEG    DATA16_C                ; Criar segmento na FLASH

        ORG     0x000
MSG_BV  DB      "BEM-VINDO"  

        ORG     0x00A
MSG_DS  DB      "Digite sua senha" 

        ORG     0x01B
MSG_SIS DB      "Sistema"

        ORG     0x023
MSG_TRV DB      "Travado!"

        ORG     0x02C
MSG_AL  DB      "Alarme" 

        ORG     0x033
MSG_ON  DB      "*/ON" 

        ORG     0x038
MSG_OFF DB      "OFF/#"  
        
        ORG     0x03E
MSG_SEQ DB      0x7F, 0x00

        ORG     0x040
MSG_SDI DB      0x7E, 0x00
        
        ORG     0x042
MSG_SEN DB      "Senha" 
        
        ORG     0x048
MSG_ALS DB      "*/Alter. senha"      
        
        ORG     0x057
MSG_NS DB       "Nova senha:"

        ORG     0x063
MSG_CON DB      "Confirme a senha"    

        ORG     0x074
MSG_SES DB      "Senhas"

        ORG     0x07B
MSG_INC DB      "Incompativeis"

        ORG     0x089
MSG_SAL DB      "Senha salva!"

        ORG     0x096
MSG_ATV DB      "Ativado!"

        ORG     0x09F
MSG_DES DB      "Desativado!"  

        ORG     0x0AB
MSG_DIS DB      "Disparado!"  

        ORG     0x0B6
MSG_SEG DB      "0 segundos para" 

        ORG     0x0C6
MSG_ATA DB      "ativar o alarme!" 

        ORG     0x0D7
MSG_ICR DB      "Incorreta!"

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer  
        
        ; Configurar CLOCK
        CLR.B   DCOCTL                  ; limpar DCOCTL
        MOV.B   CALBC1_1MHZ, BCSCTL1    ; selecionar clock de 1MHZ
        MOV.B   CALDCO_1MHZ, DCOCTL     ;   
        
        ; Configurar IO
        MOV.B   #0xF0, P1DIR            ; Definir pinos que serão entrada e saída
        MOV.B   #0x0F, P1REN            ; Ativar pull-down para as linhas do teclado
        MOV.B   #0x40, P1OUT            ; Deixar ativa apenas a terceira coluna
        MOV.B   #0x0F, P1IE             ; Ativar interrupções de B0~B4 para o teclado
        BIC.B   #0x0F, P1IES            ; Low para High
        CLR.B   P1IFG                   ; Limpar flags
       
        CLR.B   P2SEL                   ; Desativar funções especiais 
        CLR.B   P2SEL2                  ; Desativar funções especiais 
        MOV.B   #0x7F, P2DIR            ; Definir pinos que serão entrada e saída
        MOV.B   #0x80, P2REN            ; Ativar resistor interno para o sensor
        MOV.B   #0x40, P2OUT            ; Limpar saída, ligar o display e configurar res. como pull-down
        CLR.B   P2IE                    ; Desativar interrupção da porta 2
        BIC.B   #0x80, P2IES            ; Low para High
        BIC.B   #0x80, P2IFG            ; Limpar flags
       
        BIT.B   #0x08, P1IN             ; "#" está pressionado?
        JZ      carregar_senha          ; Não, carregar da FLASH a senha salva
        
        ; Limpar senha na flash
        MOV     #FWKEY, &FCTL3          ; Limpar LOCK
        MOV     #FWKEY + ERASE, &FCTL1  ; Ativar ERASE
        CLR     &SEN_SAV                ; Limpar segmento da memória
        MOV     #FWKEY + LOCK, &FCTL3   ; Setar LOCK
carregar_senha
        BIS.B   #0x70, P1OUT            ; Ativar todas as colunas
        CALL    #LOAD_SENHA             ; Carregar senha da flash para a RAM
        
        MOV.W   #100, R14               ; Tempo para o delay
        CALL    #DELAY_MS               ; Delay de 100ms
        
        ; Configura o display 3 vezes para garantir que não há erros
        MOV.B   #0x03, R6               ; Contador recebe 3
config_dis 
        MOV.B   #0x00, R4               ; Selecionar envio de instrução
        
        MOV.B   #0x20, R5               ; Comando de inicialização
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display
        CALL    #DELAY_MS               ; Delay de 100ms
        
        MOV.B   #0x28, R5               ; 4 bits; 2 linhas
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display 
        CALL    #DELAY_MS               ; Delay de 100ms
        
        MOV.B   #0x0C, R5               ; Display ON; Cursor OFF; Pos. cursor OFF
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display    
        CALL    #DELAY_MS               ; Delay de 100ms
        
        MOV.B   #0x01, R5               ; Limpar display
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display  
        CALL    #DELAY_MS               ; Delay de 100ms
        DEC     R6                      ; Decrementar contador
        JNZ     config_dis              ; Volta se contador não for zero
        
        ; Limpar flags gerais e inicializar variáveis
        MOV.B   #INICIO, &STATUS        ; Trocar o status para "INICIANDO"
        CLR     &QTD_ERR                ; Zerar contador de senhas incorretas
        CLR     &QTD_DIG                ; Zerar quantidade já digitada
        CLR     &TR_MENU                ; Desabilitar troca de menus
        
        ; Exibir mensagem de boas-vindas
        MOV.W   #MSG_BV, R6             ; End. da String
        MOV.B   #0x03, R7               ; Linha 1, coluna 3
        CALL    #LCD_STRING             ; Enviar string para o display
        
        EINT                            ; Habilitar interrupções
        MOV.B   #LPM4 + GIE, SR         ; Ativar standBy
        
main_loop:
        CMP.B   #TRAVADO, &STATUS       ; Travar o sistema?
        JEQ     travar                  ; Sim
        CMP.B   #VALIDAR, &STATUS       ; Validar senha?
        JEQ     validar                 ; Sim
        CMP.B   #ALT_SAV, &STATUS       ; Salvar senha alterada?
        JEQ     alter_senha             ; Sim
        CMP.B   #ALM_ON, &STATUS        ; Ativar alarme?
        JEQ     ativar_alm              ; Sim
        CMP.B   #ALM_OFF, &STATUS       ; Desativar alarme?
        JEQ     desat_alm               ; Sim
        CMP.B   #ALM_DIS, &STATUS       ; Alarme disparado?
        JEQ     alm_dispar              ; Sim
        CMP.B   #TRUE, &TR_MENU         ; Trocar de menu?
        JEQ     trocar_menu             ; Sim
        JMP     main_loop               ; Voltar para o loop
;------------------------------------------------------------------------------;
;------------------------------------------------------------------------------; 
alm_dispar: 
        CALL    #PISCAR                 ; Piscar o display      
        JMP     main_loop               ; Voltar para o loop principal
;------------------------------------------------------------------------------;
;------------------------------------------------------------------------------;
ativar_alm:
        DINT                            ; Desabilitar interrupções gerais   
        BIC.B   #0x80, P1OUT            ; Desativar buzzer
        
        MOV.B   #0x33, R8               ; Vezes que fará o loop para executar o alarme (em ascii)
loop_atv
        ; Limpar display
        MOV.B   #0x00, R4               ; Enviar comando
        MOV.B   #0x01, R5               ; Limpar display
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display
        
        MOV.B   #0x01, R4               ; Enviar dado
        MOV.B   R8, R5                  ; Enviar valor de R8
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display
        
        MOV.W   #MSG_SEG, R6            ; End. da mensagem "0 segundos..."
        MOV.B   #0x01, R7               ; Linha 1, coluna 1
        CALL    #LCD_STRING             ; Enviar string para o display

        MOV.W   #MSG_ATA, R6            ; End. da mensagem "ativar o alarme!"
        MOV.B   #0x10, R7               ; Linha 2, coluna 1
        CALL    #LCD_STRING             ; Enviar string para o display
        
        ; Delay de ~10s
        MOV.W   #10000, R14             ; Tempo para o delay em ms
        CALL    #DELAY_MS               ; Delay de 10ms

        DEC     R8                      ; Decrementar contador
        CMP.B   #0x30, R8               ; R8 é igual a zero? (em ascii)
        JNE     loop_atv                ; Não, voltar
        
        MOV.B   #INICIO, &STATUS        ; Alterar a flag de status para INICIO
        BIS.B   #0x80, P2IE             ; Ativar interrupção do sensor
        BIC.B   #0x80, P2IFG            ; Limpar flag
        
        EINT                            ; Habilitar interrupções gerais 
        BIC.B   #0x40, P2OUT            ; Desligar o display
        MOV.B   #LPM4 + GIE, SR         ; Ativar standBy
        
        JMP     main_loop               ; Voltar para o loop principal
;------------------------------------------------------------------------------;
;------------------------------------------------------------------------------; 
desat_alm: 
        DINT                            ; Desabilitar interrupções gerais  
        BIC.B   #0x80, P2IE             ; Desativar interrupção do sensor
        BIC.B   #0x80, P2IFG            ; Limpar flag
        BIC.B   #0x80, P1OUT            ; Desativar buzzer
        
        ; Exibir alarme ativado
        MOV.B   #0x00, R4               ; Enviar comando
        MOV.B   #0x01, R5               ; Limpar display
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display
        
        MOV.W   #MSG_AL, R6             ; End. da mensagem "Alarme"
        MOV.B   #0x05, R7               ; Linha 1, coluna 6
        CALL    #LCD_STRING             ; Enviar string para o display

        MOV.W   #MSG_DES, R6            ; End. da mensagem "Desativado!"
        MOV.B   #0x13, R7               ; Linha 2, coluna 4
        CALL    #LCD_STRING             ; Enviar string para o display    
        
        EINT                            ; Habilitar interrupções gerais
        ; Delay de ~10s (Evita que fique travado caso alguma interrupção seja acionada)
        MOV.W   #1000, R4               ; Repetir o delay 1000 vezes
        MOV.W   #10, R14                ; Tempo para o delay em ms
loop_des
        CMP.B   #ALM_OFF, &STATUS       ; Alarme desativado?
        JNE     main_loop               ; Não, voltar para o loop principal
        CALL    #DELAY_MS               ; Delay de 10ms
        DEC     R4                      ; Decrementar R4
        JNZ     loop_des                ; Volta até R4 ser zero
        
        BIC.B   #0x40, P2OUT            ; Desligar o display
        MOV.B   #INICIO, &STATUS        ; Alterar a flag de status para INICIO
        MOV.B   #LPM4 + GIE, SR         ; Ativar standBy
        JMP     main_loop               ; Voltar para o loop principal
;------------------------------------------------------------------------------;
;------------------------------------------------------------------------------;
alter_senha:
        MOV.B   #0x00, R4               ; Enviar comando
        MOV.B   #0x01, R5               ; Limpar display
        CALL    #LCD_SEND_BYTE          ; Enviar byte
        MOV.B   #0x0C, R5               ; Desabilitar cursor
        CALL    #LCD_SEND_BYTE          ; Enviar byte 
        
        ; Comparar senha digitada com senha definida
        MOV.B   #0x08, R4               ; Contador recebe 8
        MOV.W   #SEN_DIG, R5            ; R5 recebe o end. inicial da senha digitada
        MOV.W   #SEN_DEF, R6            ; R6 recebe o end. inicial da senha digitada 
loop_as CMP.B   0(R5), 0(R6)            ; Carac. apontado por R5 é igual a carac. apontado por R6?             
        JNE     diferentes              ; Não, pular
        INC     R6                      ; Sim, incrementar R6
        INC     R5                      ; Incrementar R5
        DEC     R4                      ; Decrementar o contador
        JNZ     loop_as                 ; Voltar se contador não for zero
        JMP     salvar_senha            ; Quando contador igual a zero, salvar a senha
        
diferentes        
        MOV.W   #MSG_SES, R6            ; End. da mensagem "Senhas"
        MOV.B   #0x05, R7               ; Linha 1, coluna 6
        CALL    #LCD_STRING             ; Enviar string para o display
        MOV.W   #MSG_INC, R6            ; End. da mensagem "Incompativeis"
        MOV.B   #0x11, R7               ; Linha 2, coluna 2
        CALL    #LCD_STRING             ; Enviar string para o display
        CALL    #LOAD_SENHA             ; Carregar a senha salva na FLASH
        MOV.W   #2000, R14              ; Tempo para o delay
        CALL    #DELAY_MS               ; Delay de ~2s
        JMP     fim_as                  ; Finalizar
        
salvar_senha
        MOV.B   #0x08, R4               ; R4 recebe o tamanho da senha
        MOV.W   #SEN_DIG, R5            ; R5 recebe o end. inicial da senha digitada
        MOV.W   #SEN_SAV, R6            ; R6 recebe o end. inicial do local onde a senha será salva
        
        MOV     #FWKEY, &FCTL3          ; Limpar LOCK
        MOV     #FWKEY + ERASE, &FCTL1  ; Ativar ERASE
        CLR     &SEN_SAV                ; Apagar o segmento
volt_salvar
        MOV     #FWKEY + WRT, &FCTL1    ; Ativar WRITE
        MOV.B   0(R5), 0(R6)            ; Salvar carac. apontado por R5
        MOV     #FWKEY, &FCTL1          ; Desativar WRITE
        INC     R5                      ; Prox. carac. em R5
        INC     R6                      ; Prox. carac. em R6
        DEC     R4                      ; Decrementar contador
        JNZ     volt_salvar             ; Voltar se contador não for zero
        MOV     #FWKEY + LOCK, &FCTL3   ; Ativar LOCK
         
        ; Exibir "senha salva" 
        MOV.W   #MSG_SAL, R6            ; Exibir "Senha"
        MOV.B   #0x02, R7               ; Linha 1, coluna 3
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #2000, R14              ; Tempo para o delay
        CALL    #DELAY_MS               ; Delay de ~2s
fim_as
        MOV.B   #MENU_2, &STATUS        ; Alterar o status para o menu 2                
        MOV.B   #TRUE, &TR_MENU         ; Habilitar troca de menus
        BIS.B   #0x0F, P1IE             ; Habilitar as interrupções do teclado
        JMP     main_loop               ; Voltar para o loop principal
;------------------------------------------------------------------------------;
;------------------------------------------------------------------------------;
trocar_menu:
        MOV.B   #FALSE, TR_MENU         ; Desabilitar a troca de menus
        CMP.B   #MENU, &STATUS          ; Status é igual ao MENU 1?
        JEQ     menu_1                  ; Sim, pular
        JMP     menu_2                  ; Não, pular
        
validar:
        MOV.B   #0x08, R4               ; R4 recebe o tamanho da senha
        MOV.W   #SEN_DIG, R5            ; R5 recebe o end. inicial da senha digitada
        MOV.W   #SEN_DEF, R6            ; R6 recebe o end. inicial da senha definida
        
prox_lt CMP     0(R5), 0(R6)            ; Carac. apontado por R5 é igual a carac. apontado por R6?       
        JNE     senha_errada            ; Não... Senha incorreta!
        INC     R5                      ; Incrementar apontador da senha digitada
        INC     R6                      ; Incrementar apontador da senha definida
        DEC     R4                      ; Decrementar contador
        JNZ     prox_lt                 ; Se contador não for igual a 0, testar a prox. letra
        MOV.B   #MENU, &STATUS          ; Senha correta; Status é igual a menu
        BIS.B   #0x0F, P1IE             ; Habilitar as interrupções do teclado
        JMP     menu_1                  ; Abrir o menu
          
senha_errada:
        INC     &QTD_ERR                ; Incrementar contador de erros
        CMP.B   #0x05, &QTD_ERR         ; Contador de erros é igual a 5?
        JEQ     travar                  ; Sim, travar o sistema
        
        ; Exibir senha incorreta
        MOV.B   #0x00, R4               ; Enviar comando
        MOV.B   #0x01, R5               ; Limpar display
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display
        
        MOV.B   #0x0C, R5               ; Desabilitar cursor
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display 
        
        MOV.W   #MSG_SEN, R6            ; End. da mensagem "Senha"
        MOV.B   #0x05, R7               ; Linha 1, coluna 6
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #MSG_ICR, R6             ; End. da mensagem "Incorreta!"
        MOV.B   #0x13, R7               ; Linha 2, coluna 4
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #2000, R14              ; Tempo para o delay
        CALL    #DELAY_MS               ; Delay de ~2s
        
        MOV.B   #INICIO, &STATUS        ; Trocar o status para "INICIO"
        BIS.B   #0x0F, P1IE             ; Habilitar as interrupções do teclado
        CLR     &QTD_DIG                ; Zerar contador de digitos
                
        JMP     main_loop               ; Voltar para o loop principal

menu_1:
        ; Limpar senha e contador de senhas erradas
        BIC.B   #0x80, P2IE             ; Desativar interrupção do sensor
        BIC.B   #0x80, P1OUT            ; Desativar buzzer
        CLR     &QTD_ERR                ; Limpar contador de senhas incorretas
        MOV.W   #SEN_DIG, R4            ; R4 aponta para end. inicial da senha digitada
        MOV.B   #0x08, R5               ; Contador para a senha
loop_clr                                ; loop para limpar senha digitada
        MOV.B   #0x23, 0(R4)            ; Enviar "*" para senha digitada
        INC     R4                      ; Incrementar apontador
        DEC     R5                      ; Incrementar contador
        JNZ     loop_clr                ; Repetir o loop se o contador não for zero
        
        ; Exibir menu
        MOV.B   #0x00, R4               ; Enviar comando
        MOV.B   #0x01, R5               ; Limpar display
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display
        
        MOV.B   #0x0C, R5               ; Desabilitar cursor
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display 
        
        MOV.W   #MSG_SEQ, R6            ; End. da seta para esquerda
        MOV.B   #0x00, R7               ; Linha 1, coluna 1
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #MSG_AL, R6             ; End. da mensagem "Alarme"
        MOV.B   #0x05, R7               ; Linha 1, coluna 6
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #MSG_SDI, R6            ; End. da seta para direita
        MOV.B   #0x0F, R7               ; Linha 1, coluna 16
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #MSG_ON, R6             ; End. da mensagem "*/on"
        MOV.B   #0x10, R7               ; Linha 2, coluna 1
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #MSG_OFF, R6            ; End. da mensagem "off/#"
        MOV.B   #0x1B, R7               ; Linha 2, coluna 12
        CALL    #LCD_STRING             ; Enviar string para o display
        
        JMP     main_loop               ; Voltar para o loop principal

menu_2:        
        ; Exibir menu 2
        MOV.B   #0x00, R4               ; Enviar comando
        MOV.B   #0x01, R5               ; Limpar display
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display
        
        MOV.B   #0x0C, R5               ; Desabilitar cursor
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display  
        
        MOV.W   #MSG_SEQ, R6            ; End. da seta para esquerda
        MOV.B   #0x00, R7               ; Linha 1, coluna 1
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #MSG_SEN, R6            ; End. da mensagem "Alarme"
        MOV.B   #0x05, R7               ; Linha 1, coluna 6
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #MSG_SDI, R6            ; End. da seta para direita
        MOV.B   #0x0F, R7               ; Linha 1, coluna 16
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #MSG_ALS, R6            ; End. da mensagem "* on"
        MOV.B   #0x10, R7               ; Linha 2, coluna 1
        CALL    #LCD_STRING             ; Enviar string para o display
        
        JMP     main_loop               ; Voltar para o loop principal
;------------------------------------------------------------------------------;
;------------------------------------------------------------------------------;
travar:
        DINT                            ; Desabilitar interrupções gerais
        BIS.B   #0x80, P1OUT            ; Acionar buzzer
        
        ; Exibir mensagem "Sistema travado"
        MOV.B   #0x00, R4               ; Enviar comando
        MOV.B   #0x01, R5               ; Limpar display
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display
        
        MOV.B   #0x0C, R5               ; Desabilitar cursor
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display  
        
        MOV.W   #MSG_SIS, R6            ; End. da mensagem "Sistema"
        MOV.B   #0x04, R7               ; Linha 1, coluna 5
        CALL    #LCD_STRING             ; Enviar string para o display
        
        MOV.W   #MSG_TRV, R6            ; End. da mensagem "Travado!"
        MOV.B   #0x14, R7               ; Linha 2, coluna 5
        CALL    #LCD_STRING             ; Enviar string para o display
                
loop_trava        
        CALL    #PISCAR                 ; Piscar o display
        JMP     loop_trava              ; Loop eterno
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subrotina: PISCAR
; Descrição: Inverte o estado do bit de acionamento do display.
; Entrada: - 
; Saída: - 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PISCAR:
      XOR.B   #0x40, P2OUT              ; Piscar o display
      MOV.W   #300, R14                 ; Tempo para o delay
      CALL    #DELAY_MS                 ; Delay de 300ms  
      RET                               ; Retorno
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subrotina: LOAD_SENHA
; Descrição: Carrega a senha salva na FLASH para a RAM. 
; Entrada: - 
; Saída: SEN_DEF -> Apontará para a senha carregada.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LOAD_SENHA:
        PUSH    R4                      ; Salvar contexto
        PUSH    R5                      ;
        PUSH    R6                      ;
        
        ; Carregar senha para a RAM
        MOV.W   #SEN_SAV, R4            ; R4 aponta para end. inicial da senha salva
        MOV.W   #SEN_DEF, R5            ; R5 aponta para end. inicial da senha definida
        MOV.B   #0x08, R6               ; Contador recebe 8
loop_sen
        CMP.B   #0xFF, 0(R4)            ; Está vazio?
        JEQ     con_loop                ; Sim, pular
        MOV.B   0(R4), 0(R5)            ; Não, mover para R5
        JMP     inc_loop                ; Pular
con_loop  
        MOV.B   #0x30, 0(R5)            ; Carregar 0 em ascii para R5
inc_loop        
        INC     R4                      ; Incrementar apontador da senha salva
        INC     R5                      ; Incrementar apontador da senha definida
        DEC     R6                      ; Decrementar contador
        JNZ     loop_sen                ; Voltar se contador não for zero
        MOV.B   #0x00, 0(R5)            ; Adicionar "/0" ao final da senha
        
        POP     R6                      ; Restaurar contexto
        POP     R5                      ;
        POP     R4                      ;
        RET                             ; Retorno
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subrotina: P2_ISR
; Descrição: * Trata a interrupção para o sensor.
;            * Ao executar aciona o buzzer
;            * Exibe mensagem na tela se necessário
;            * Desativa o modo de standby.
; Entrada: - 
; Saída: - 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
P2_ISR:
        BIS.B   #0x80, P1OUT            ; Acionar buzzer
        BIC.B   #0x80, P2IFG            ; Limpar flag do sensor
        BIC.B   #0x80, P2IE             ; Desativar interrupção do sensor
        
        CMP.B   #DIGITAN, &STATUS       ; Digitando a senha?
        JEQ     fim_p2_isr              ; Sim, finalizar
        MOV.B   #ALM_DIS, &STATUS       ; Não, alterar status para alarme disparado            
        
        ; Exibir alarme disparado
        MOV.B   #0x00, R4               ; Enviar comando
        MOV.B   #0x01, R5               ; Limpar display
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display
        
        MOV.W   #MSG_AL, R6             ; End. da mensagem "Alarme"
        MOV.B   #0x05, R7               ; Linha 1, coluna 6
        CALL    #LCD_STRING             ; Enviar string para o display

        MOV.W   #MSG_DIS, R6            ; End. da mensagem "Disparado!"
        MOV.B   #0x13, R7               ; Linha 2, coluna 4
        CALL    #LCD_STRING             ; Enviar string para o display
fim_p2_isr  
        BIC     #LPM4, 0(SP)            ; Desativar standby
        RETI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subrotina: P1_ISR
; Descrição: * Trata a interrupção da porta 1, mais precisamente do teclado; 
;            * Não altera o valor dos registradores (Rx);
;            * Modifica as flags STATUS, e TR_MENU; e o contador de caracteres, QTD_DIG;
;            * Desativa o modo de standby.
; Entrada: - 
; Saída: STATUS  -> Altera o status de acordo com a cobinação de teclas;
;        TR_MENU -> Altera para TRUE se for solicitado a troca de menus;
;        QTD_DIG -> Qtd. de digitos que estão sendo exibidos no display como "*". 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
P1_ISR: 
        PUSH    R14                     ; Salvar contexto
        PUSH    R8                      ;
        PUSH    R7                      ;
        PUSH    R6                      ;
        PUSH    R5                      ;
        PUSH    R4                      ;
        
        MOV.B   P1IFG, R8               ; Identificar tecla pressionada
        CALL    #READ_KEY               ; Ler teclado
        CMP.W   #0xFFFF, R8             ; Houve erro na leitura do teclado?
        JEQ     fim_p1_isr              ; Se sim, finalizar.
        
        BIS.B   #0x40, P2OUT            ; Ligar display
                                        ; Validar qual o status do sistema
        CMP.B   #MENU, &STATUS          ; Está no menu 1?
        JEQ     flag_menu               ; Sim...
        CMP.B   #MENU_2, &STATUS        ; Não... Está no menu 2?
        JEQ     flag_menu               ; Sim...
        CMP.B   #ALT_SEN, &STATUS       ; Não... Está no modo de alteração de senha?
        JEQ     acres_carac             ; Sim...
        CMP.B   #DIGITAN, &STATUS       ; Não... Está digitando a senha?
        JNE     reset_senha             ; Não, modificar o status e exibir msg     

acres_carac:
        CMP.B   #0x23, R8               ; Apertou a tecla "#"?
        JEQ     reset_senha             ; Resetar senha
        
        MOV.W   #SEN_DIG, R6            ; R7 recebe o endereço para armazenar senha
        MOV.B   &QTD_DIG, R7            ; R7 recebe a qtd. digitada
        ADD.W   R7, R6                  ; Somar end. senha com qtd. digitada        
        MOV.B   R8, 0(R6)               ; Armazenar 1 caracter da senha na memória        
        INC.B   &QTD_DIG                ; Incrementar qtd. já digitada
        CMP.B   #0x08, &QTD_DIG         ; Digitou oito vezes?
        JEQ     pass_end                ; Sim...Pular
                                   
        ; Acresentar o "*" ao display
        MOV.B   #0x01, R4               ; Selecionar envio de dados
        MOV.B   #0x2A, R5               ; Enviar "*"
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display  
        JMP     delay_p1_isr            ; Finalizar

        ; Alterar flag para trocar de menu
flag_menu:
        CMP.B   #0x34, R8               ; Tecla = 4?
        JEQ     alterar_menu            ; Sim, alterar menu
        CMP.B   #0x36, R8               ; Tecla = 6?
        JEQ     alterar_menu            ; Sim, alterar menu
        CMP.B   #0x2A, R8               ; Tecla = *?
        JEQ     tc_aster                ; Sim, verificar função
        CMP.B   #0x23, R8               ; Tecla = #?
        JEQ     tc_antihi               ; Sim, verificar se está no menu 2
        JMP     fim_p1_isr              ; Nenhuma das duas, finalizar

tc_antihi                               ; Ao precissonar "#" 
        CMP.B   #MENU, &STATUS          ; Está no menu 1?
        JNE     delay_p1_isr            ; Não, delay e finalizar             
        MOV.B   #ALM_OFF, &STATUS       ; Modificar flag para desativar o alarme
        JMP     delay_p1_isr            ; Delay e finalizar

tc_aster                                ; Está em algum menu e pressionou "*"
        CMP.B   #MENU, &STATUS          ; Está no menu 1?
        JEQ     menu1_aster             ; Menu 1 
        
        ; Ao precissonar "*" no menu 2 
        MOV.B   #ALT_SEN, &STATUS       ; Entrar no modo de alterar senha
        MOV.B   #FALSE, &CON_SEN        ; sub-modo "nova senha"
        JMP     reset_senha             ; 
        
menu1_aster                             ; Ao precissonar "*" no menu 1 
        MOV.B   #ALM_ON, &STATUS        ; Modificar flag para ativar o alarme
        JMP     delay_p1_isr            ; Delay e finalizar
        
alterar_menu
        MOV.B   #TRUE, &TR_MENU         ; Habilitar flag para trocar de menu
        CMP.B   #MENU, &STATUS          ; Está no menu 1?
        JEQ     fim_menu                ; Sim...
        MOV.B   #MENU, &STATUS          ; Alterar a flag para menu 1
        JMP     delay_p1_isr            ; Finalizar
fim_menu    
        MOV.B   #MENU_2, &STATUS        ; Alterar a flag para menu 2
        JMP     delay_p1_isr            ; Finalizar
        
        
pass_end:                               ; Após digitar 8 caracteres
        BIC.B   #0x0F, P1IE             ; Desabilitar as interrupções do teclado
        CMP.B   #ALT_SEN, &STATUS       ; STATUS é igual a alterar senha?
        JEQ     modo_salvar             ; Sim, pular
        MOV.B   #VALIDAR, &STATUS       ; Não, alterar status para validando
        JMP     delay_p1_isr            ; Finalizar
modo_salvar:
        CMP.B   #FALSE, &CON_SEN        ; É sub-modo confirmar senha?
        JEQ     con_senha               ; Sim, pular
        MOV.B   #ALT_SAV, &STATUS       ; Não, alterar status para salvar senha alterada
        JMP     delay_p1_isr            ; Finalizar
        
con_senha:
        ; Mover senha digitada para senha definida
        MOV.B   #0x08, R4               ; R4 recebe 8 (contador para a senha)
        MOV.W   #SEN_DIG, R5            ; R5 recebe o end. inicial da senha digitada
        MOV.W   #SEN_DEF, R6            ; R6 recebe o end. inicial da senha definida
loop_ns MOV.B   0(R5), 0(R6)            ; Mover carac. da senha digitada para senha definida
        INC     R6                      ; Incrementar R6
        INC     R5                      ; Incrementar R5
        DEC     R4                      ; Decrementar contador
        JNZ     loop_ns                 ; Jumper até o contador zerar
        
        MOV.B   #TRUE, &CON_SEN         ; sub-modo "confirmar senha"
        BIS.B   #0x0F, P1IE             ; Habilitar as interrupções do teclado

reset_senha:
        CLR     &QTD_DIG                ; Zerar contador de digitos
        
        MOV.B   #0x00, R4               ; Selecionar envio de instrução      
        MOV.B   #0x01, R5               ; Limpar display
        CALL    #LCD_SEND_BYTE          ; Enviar byte para o display
        
        CMP.B   #ALT_SEN, &STATUS       ; STATUS é igual a alterar senha?
        JNE     digite_senha            ; Não, exibir "digitando a senha"
                                        ; Sim...
        CMP.B   #FALSE, &CON_SEN        ; Está no modo de nova senha?
        JEQ     new_senha               ; Sim, exibir "nova senha"
                                        ; Não, exibir "confime a senha"
        MOV.W   #MSG_CON, R6            ; End. da String
        MOV.B   #0x00, R7               ; Linha 1, coluna 1
        CALL    #LCD_STRING             ; Enviar String
        JMP     ativar_cursor           ; Ativar cursor
        
new_senha:                              ; Exibir nova senha
        MOV.W   #MSG_NS, R6             ; End. da String
        MOV.B   #0x00, R7               ; Linha 1, coluna 1
        CALL    #LCD_STRING             ; Enviar String
        JMP     ativar_cursor           ; Ativar cursor
        
digite_senha:                           ; Exibir "digite sua senha"      
        MOV.W   #MSG_DS, R6             ; End. da String
        MOV.B   #0x00, R7               ; Linha 1, coluna 1
        CALL    #LCD_STRING             ; Exibir string
        MOV.B   #DIGITAN, &STATUS       ; Alterar status para digitando
        
ativar_cursor:
        MOV.B   #0x00, R4               ; Selecionar envio de instrução
        MOV.B   #0xC0, R5               ; Mover cursor para linha 2
        CALL    #LCD_SEND_BYTE          ; Enviar byte
        MOV.B   #0x0D, R5               ; Habilitar Pos. cursor
        CALL    #LCD_SEND_BYTE          ; Enviar byte
delay_p1_isr: 
        MOV     #150, R14               ; Delay ~150ms
        CALL    #DELAY_MS               ; 
        
fim_p1_isr   
        BIC.B   #0x0F, P1IFG            ; Limpar flag 
        
        POP     R4                      ; Restaurar contexto
        POP     R5                      ;
        POP     R6                      ;
        POP     R7                      ;
        POP     R8                      ;
        POP     R14                     ;
        
        BIC     #LPM4, 0(SP)            ; Desativar standby
retorno 
        RETI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subrotina: READ_KEY
; Descrição: Verifica qual tecla foi pressionada
; Entrada: R8 -> Status do registrador PxIFG ao chamar a subrotina.
; Saída: R8 -> Valor em ascii. Retorna 0xFFFF se encontrar algum erro.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
READ_KEY        
        ; Primeira coluna
col_1   BIC.B   #0x60, P1OUT            ; Deixar apenas a col. 1 em nível alto
        BIS.B   #0x10, P1OUT            ; 
        BIT.B   #0x0F, P1IN             ; Há algum bit ativo pela coluna 1?
        JZ      col_2                   ; Não... Testar coluna 2
        
        BIT.B   #0x01, R8               ; Linha 1 está ativa?
        JZ      pos_2_1                 ; Não... Testar linha 2
        MOV.B   #0x31, R8               ; Sim... Adicionar 1 (ascii) em R8
        JMP     fim                     ; Finalizar
        
pos_2_1 BIT.B   #0x02, R8               ; Linha 2 está ativa?
        JZ      pos_3_1                 ; Não... Testar linha 3
        MOV.B   #0x34, R8               ; Sim... Adicionar 4 (ascii) em R8
        JMP     fim                     ; Finalizar
        
pos_3_1 BIT.B   #0x04, R8               ; Linha 3 está ativa?
        JZ      pos_4_1                 ; Não... Testar linha 4
        MOV.B   #0x37, R8               ; Sim... Adicionar 7 (ascii) em R8
        JMP     fim                     ; Finalizar
        
pos_4_1 BIT.B   #0x08, R8               ; Linha 4 está ativa?
        JZ      erro                    ; Não... Informar erro
        MOV.B   #0x2A, R8               ; Sim... Adicionar * (ascii) em R8
        JMP     fim                     ; Finalizar
        
        ; Segunda coluna
col_2   BIC.B   #0x50, P1OUT            ; Deixar apenas a col. 2 em nível alto
        BIS.B   #0x20, P1OUT            ;
        BIT.B   #0x0F, P1IN             ; Há algum bit ativo pela coluna 2?
        JZ      col_3                   ; Não... Testar coluna 3
        
        BIT.B   #0x01, R8               ; Linha 1 está ativa?               
        JZ      pos_2_2                 ; Não... Testar linha 2                 
        MOV.B   #0x32, R8               ; Sim... Adicionar 2 (ascii) em R8               
        JMP     fim                     ; Finalizar                     
        
pos_2_2 BIT.B   #0x02, R8               ; Linha 2 está ativa?               
        JZ      pos_3_2                 ; Não... Testar linha 3                 
        MOV.B   #0x35, R8               ; Sim... Adicionar 5 (ascii) em R8               
        JMP     fim                     ; Finalizar                     
        
pos_3_2 BIT.B   #0x04, R8               ; Linha 3 está ativa?               
        JZ      pos_4_2                 ; Não... Testar linha 4                 
        MOV.B   #0x38, R8               ; Sim... Adicionar 8 (ascii) em R8               
        JMP     fim                     ; Finalizar                    
        
pos_4_2 BIT.B   #0x08, R8               ; Linha 4 está ativa?               
        JZ      erro                    ; Não... Informar erro                    
        MOV.B   #0x30, R8               ; Sim... Adicionar 0 (ascii) em R8               
        JMP     fim                     ; Finalizar                     

        ; Terceira coluna
col_3   BIC.B   #0x30, P1OUT            ; Deixar apenas a col. 3 em nível alto
        BIS.B   #0x40, P1OUT            ; 
        BIT.B   #0x0F, P1IN             ; Há algum bit ativo pela coluna 3?
        JZ      erro                    ; Não... Informar erro  
                
        BIT.B   #0x01, R8               ; Linha 1 está ativa?                
        JZ      pos_2_3                 ; Não... Testar linha 2                  
        MOV.B   #0x33, R8               ; Sim... Adicionar 3 (ascii) em R8                
        JMP     fim                     ; Finalizar                     
        
pos_2_3 BIT.B   #0x02, R8               ; Linha 2 está ativa?               
        JZ      pos_3_3                 ; Não... Testar linha 3                 
        MOV.B   #0x36, R8               ; Sim... Adicionar 6 (ascii) em R8               
        JMP     fim                     ; Finalizar                     
        
pos_3_3 BIT.B   #0x04, R8               ; Linha 3 está ativa?               
        JZ      pos_4_3                 ; Não... Testar linha 4                 
        MOV.B   #0x39, R8               ; Sim... Adicionar 9 (ascii) em R8               
        JMP     fim                     ; Finalizar                     
        
pos_4_3 BIT.B   #0x08, R8               ; Linha 4 está ativa?               
        JZ      erro                    ; Não... Informar erro                    
        MOV.B   #0x23, R8               ; Sim... Adicionar # (ascii) em R8               
        JMP     fim                     ; Finalizar                     
   
erro    MOV.W   #0xFFFF, R8             ; Adicionar -1 ao retorno

fim     BIS.B   #0x70, P1OUT            ; Deixar todas as colunas em nível alto
        RET                             ; Retorno
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subrotina: LCD_STRING
; Descrição: Exibe no display uma string recebida por meio de um endereço inicial 
;            recebido em R6 e finalizada por 0x00. O local de exibição é controlado
;            por R7, onde, partindo do LSB, o primeiro nibble define a coluna e o
;            segundo define a linha. Ex.: 0x0F -> linha 1, coluna 16
;            Obs.: R7 deverá ter um valor entre 0x0000 e 0x001F
;
; Entrada: R6, endereço inicial da String a ser exibida;
;          R7, seleciona a linha e a coluna. 
; Saída: -
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LCD_STRING:
        PUSH    R4                      ; Salvar contexto 
        PUSH    R5                      ;
        PUSH    R6                      ;  
        PUSH    R7                      ;

        MOV.B   #0x80, R5               ; Trocar cursor de local
        BIT.B   #0x10, R7               ; É a primeira linha?
        JZ      add_col                 ; Sim, adicionar a col. ao comando
        BIS.B   #0x40, R5               ; Não, adicionar a segunda linha ao comando
        
add_col BIC.B   #0xF0, R7               ; Deixar apenas a coluna em R7
        BIS.B   R7, R5                  ; Adicionar a coluna ao comando
        MOV.B   #0x00, R4               ; Selecionar envio de comando
        CALL    #LCD_SEND_BYTE          ; Enviar comando
        
        MOV.B   #0x01, R4               ; Selecionar envio de dados        
str_loop 
        CMP.B   #0x00, 0(R6)            ; Conteúdo apontado por R6 é igual a "\0"? 
        JEQ     fim_str                 ; Se sim, finaliza
        MOV.B   0(R6), R5               ; senão, mover o conteúdo para R5
        CALL    #LCD_SEND_BYTE          ; Enviar byte  
        INC     R6                      ; Incrementar R6
        JMP     str_loop                ; voltar

fim_str POP     R7                      ; Restaurar contexto
        POP     R6                      ; 
        POP     R5                      ;
        POP     R4                      ;
        RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subrotina: LCD_SEND_BYTE
; Descrição: Envia um byte de comando ou dado para o display.
; Entrada: R4 seleciona se é comando ou dado; 0x00 para comando e 0x01 para dado;
;          R5 byte a ser enviado.
; Saída: -
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LCD_SEND_BYTE:
        PUSH    SR                      ; Salvar contexto
        PUSH    R6                      ; 
        PUSH    R7                      ;
        PUSH    R14
        
        BIC.B   #0x1F, P2OUT            ; limpar bits do display: (D0-D4) e (RS)       
        BIT.B   #0x01, R4               ; R4 é igual a 1(dados)?
        JZ      separar                 ; Não... Separar nibbles
        BIS.B   #0x10, P2OUT            ; Sim, RS recebe nível alto
        
separar MOV     R5, R6                  ; Copiar o valor de R5 para R6
        BIC     #0xFFF0, R6             ; Deixar apenas o nibble LSB em R6
        BIC     #0xFF0F, R5             ; Deixar apenas o nibble MSB em R5
        
        ; Mover o nibble MSB para LSB        
        MOV     #0x04, R7               ; R7 recebe 4
loop    RRA     R5                      ; Rotacionar R5
        DEC     R7                      ; Decrementar R7  
        JNZ     loop
        
        ; Enviar nibbles para o display
        BIS.B   R5, P2OUT               ; Enviar nibble MSB     
        CALL    #CLK_DISPLAY            ; Clock 
        BIC.B   #0x0F, P2OUT            ; Limpar D0~D4
        BIS.B   R6, P2OUT               ; Enviar nibble LSB     
        CALL    #CLK_DISPLAY            ; Clock
        MOV.W   #5, R14                 ; Tempo para o delay
        CALL    #DELAY_MS               ; Delay de 5ms
        
        POP     R14
        POP     R7                      ; 
        POP     R6                      ;
        POP     SR                      ; Restaurar contexto
        RET                             ; Retorno
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subrotina: CLK_DISPLAY
; Descrição: Envia um pulso de clock para o display.
; Entrada: -
; Saída: -
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CLK_DISPLAY:
        PUSH    R14                     ; Salvar contexto
        
        BIS.B   #0x20, P2OUT            ; Habilitar EN        
        MOV     #14, R14                ; Delay de ~50us
        CALL    #DELAY_US
        
        BIC.B   #0x20, P2OUT            ; Desabilitar EN        
        MOV.W   #31, R14                ; Delay de ~100us
        CALL    #DELAY_US
        
        POP     R14                     ; Restaurar contexto
        RET
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;*******************************************************************************
;Subrotina: DELAY_MS
;Descrição: Intervalo de tempo gasto pela CPU com tempo base de 1ms
;Entrada: R14, define o tempo total de atraso em milissegundos
;	     Tempo base = 3K/Fclk. Para T=1ms e Fclk=750kHz, k=250
;Saída: -
;*******************************************************************************
K	EQU	334

DELAY_MS			        			; ciclos de instrução
        PUSH	R14						; 3
        PUSH	R6						; 3
cont_ext
        MOV	#K, R6						; 2
cont_int
        DEC	R6							; 1
        JNZ	cont_int	    			; 2
        DEC	R14							; 1
        JNZ     cont_ext				; 2
        POP     R6						; 2
        POP     R14						; 2
        RET								; 3
;******************************************************************************* 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subrotina: DELAY_US
; Descrição: Delay em microsegundos. Recebe um valor por R15 e decrementa-o 
;            até zero. A função obedece à seguinte equação: 
;            Tempo em microsegundos = (3 * R14 + 8)   
;
; Entrada: R14 -> valor a ser decrementado
; Saída: -
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DELAY_US:

back_us DEC     R14                     ; Decrementa R14
        JNZ     back_us                 ; volta        
        RET                             ; Retorno
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        END
